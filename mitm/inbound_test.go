package mitm

import (
	"bufio"
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"io"
	"log/slog"
	"net"
	"os"
	"testing"
	"time"

	"github.com/alecthomas/assert/v2"
	"golang.org/x/sync/errgroup"
)

// deviceSerialInbound is a helper function which parses the given
// inbound packet data and returns the DeviceSerial field.
func deviceSerialInbound(data []byte) ([]byte, error) {
	header := InboundHeader{}
	buf := bytes.NewBuffer(data)
	if err := binary.Read(buf, binary.BigEndian, &header); err != nil {
		return nil, fmt.Errorf("couldn't read header: %v", err)
	}
	envelope := InboundEnvelope{}
	if err := binary.Read(buf, binary.BigEndian, &envelope); err != nil {
		return nil, fmt.Errorf("couldn't read envelope: %v", err)
	}
	return envelope.DeviceSerial[:], nil
}

func TestHandleInboundPacket(t *testing.T) {
	var testCases = map[string]struct {
		input       []byte
		expectError bool
	}{
		"valid metrics ack": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x03, 0x04, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x1c, 0x08, 0x00, 0x0a, 0x0a, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0xa4, 0x53, 0xf3, 0xb6, 0x0a, 0xae, 0xd0,
				0xe5, 0x49, 0x35, 0xd1, 0x04, 0xb8, 0x5b, 0x4a, 0xed, 0xfc,
			},
			expectError: false,
		},
		"meter time sync ack": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x01, 0x16, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x12, 0x0e, 0x13, 0x05, 0x0b, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x56, 0x95, 0x26, 0xdc, 0x8b, 0xa9, 0x14,
				0x7c, 0x98, 0xe7, 0xb7, 0xa6, 0x74, 0xea, 0x91, 0x14, 0x9c,
			},
			expectError: false,
		},
		"inverter time sync ack": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x01, 0x03, 0x35, 0x33, 0x30, 0x30, 0x30, 0x44, 0x53, 0x43,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x07, 0x0c, 0x16, 0x0c, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x71, 0x2c, 0x9a, 0x7b, 0xd9, 0x6a, 0xfb,
				0x5c, 0xdc, 0x42, 0xc4, 0xaf, 0x5c, 0xce, 0x0a, 0xa3, 0xef,
			},
			expectError: false,
		},
		"invalid packet": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x03, 0x04, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x1c, 0x08, 0x00, 0x0a, 0x0a, 0x17, 0x00, 0x00,
				// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0xa4, 0x53, 0xf3, 0xb6, 0x0a, 0xae, 0xd0,
				0xe5, 0x49, 0x35, 0xd1, 0x04, 0xb8, 0x5b, 0x4a, 0xed, 0xfc,
			},
			expectError: true,
		},
	}
	ctx := context.Background()
	log := slog.New(slog.NewJSONHandler(os.Stderr,
		&slog.HandlerOptions{Level: slog.LevelDebug}))
	ph := NewInboundPacketHandler()
	for name, tc := range testCases {
		t.Run(name, func(tt *testing.T) {
			_, _, err := ph.HandlePacket(ctx, log, tc.input)
			if tc.expectError {
				assert.Error(tt, err, name)
			} else {
				assert.NoError(tt, err, name)
			}
			deviceSerial, err := deviceSerialInbound(tc.input)
			assert.NoError(tt, err, name)
			// ensure test values are used
			assert.Equal(tt, []byte(testDeviceSerial), deviceSerial, name)
		})
	}
}

func TestHandleInbound(t *testing.T) {
	var testCases = map[string]struct {
		input               []byte
		expectForward       bool
		expectForwardOffset int
	}{
		"single valid metrics ack": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x03, 0x04, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x08, 0x34, 0x0d, 0x03, 0x0b, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xc9, 0x51, 0x6e, 0x47, 0x9e, 0xfa, 0xed,
				0x13, 0x7e, 0x48, 0xde, 0x86, 0xad, 0x9d, 0x42, 0xcc, 0xcb,
			},
			expectForward: true,
		},
		"single valid timesync response": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x01, 0x16, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x3a, 0x33, 0x0d, 0x03, 0x0b, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xe2, 0x8c, 0x32, 0x77, 0x19, 0xfc, 0xd2,
				0x90, 0xa7, 0xaa, 0xab, 0x5c, 0x3b, 0xf4, 0xf4, 0x69, 0x80,
			},
			expectForward: true,
		},
		"multiple valid packets": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x03, 0x03, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x1c, 0x14, 0x0e, 0x1e, 0x0a, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xcf, 0xef, 0x94, 0x8e, 0x3c, 0xa5, 0xf7,
				0x80, 0x2b, 0xe5, 0x17, 0xc6, 0x82, 0xe1, 0x89, 0x7c, 0x12,
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x01, 0x16, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x1c, 0x14, 0x0e, 0x1e, 0x0a, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x6b, 0x44, 0xa1, 0x88, 0x6b, 0x97, 0xa3,
				0x3d, 0x40, 0x77, 0x88, 0xca, 0x68, 0xe0, 0xd7, 0xdb, 0x43,
			},
			expectForward: true,
		},
		"invalid packet": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x03, 0x04, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x08, 0x34, 0x0d, 0x03, 0x0b, 0x17, 0x00, 0x00,
				// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xc9, 0x51, 0x6e, 0x47, 0x9e, 0xfa, 0xed,
				0x13, 0x7e, 0x48, 0xde, 0x86, 0xad, 0x9d, 0x42, 0xcc, 0xcb,
			},
			expectForward: false,
		},
		"invalid packet followed by 2x valid packets": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x03, 0x03, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x1c, 0x14, 0x0e, 0x1e, 0x0a, 0x17, 0x00, 0x00,
				// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xcf, 0xef, 0x94, 0x8e, 0x3c, 0xa5, 0xf7,
				0x80, 0x2b, 0xe5, 0x17, 0xc6, 0x82, 0xe1, 0x89, 0x7c, 0x12,
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x01, 0x16, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x1c, 0x14, 0x0e, 0x1e, 0x0a, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x6b, 0x44, 0xa1, 0x88, 0x6b, 0x97, 0xa3,
				0x3d, 0x40, 0x77, 0x88, 0xca, 0x68, 0xe0, 0xd7, 0xdb, 0x43,
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x01, 0x16, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x1c, 0x14, 0x0e, 0x1e, 0x0a, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x6b, 0x44, 0xa1, 0x88, 0x6b, 0x97, 0xa3,
				0x3d, 0x40, 0x77, 0x88, 0xca, 0x68, 0xe0, 0xd7, 0xdb, 0x43,
			},
			expectForward:       true,
			expectForwardOffset: 0x64,
		},
		"invalid packet bitflip followed by valid packet": {
			input: []byte{
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x03, 0x03, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x1c, 0x14, 0x0e, 0x1e, 0x0a, 0x17, 0x00, 0x00,
				0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xcf, 0xef, 0x94, 0x8e, 0x3c, 0xa5, 0xf7,
				0x80, 0x2b, 0xe5, 0x17, 0xc6, 0x82, 0xe1, 0x89, 0x7c, 0x12,
				0x47, 0x57, 0x00, 0x00, 0x00, 0x31, 0x01, 0x16, 0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x1c, 0x14, 0x0e, 0x1e, 0x0a, 0x17, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x6b, 0x44, 0xa1, 0x88, 0x6b, 0x97, 0xa3,
				0x3d, 0x40, 0x77, 0x88, 0xca, 0x68, 0xe0, 0xd7, 0xdb, 0x43,
			},
			expectForward:       true,
			expectForwardOffset: 0x3a,
		},
	}
	log := slog.New(slog.NewJSONHandler(os.Stderr,
		&slog.HandlerOptions{Level: slog.LevelDebug}))
	for name, tc := range testCases {
		t.Run(name, func(tt *testing.T) {
			// copy loop variables for closures
			name := name
			tc := tc
			// parallelize test cases so this test will complete in a timely manner
			tt.Parallel()
			// mock conns
			upstreamRead, upstreamWrite := net.Pipe()
			clientRead, clientWrite := net.Pipe()
			// set up context, and ensure it times out
			ctx, cancel := context.WithTimeout(context.Background(), 2*readTimeout)
			defer cancel()
			// set up the reader since pipe blocks writes otherwise
			var eg errgroup.Group
			buf := &bytes.Buffer{}
			eg.Go(func() error {
				// read into buf until the context expires
				for {
					if ctx.Err() != nil {
						return nil
					}
					if err := clientRead.SetReadDeadline(time.Now().Add(time.Second)); err != nil {
						tt.Fatal(err)
					}
					if _, err := io.Copy(buf, clientRead); err != nil {
						if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
							continue
						}
						return err
					}
				}
			})
			// write to conn
			eg.Go(func() error {
				_, err := upstreamWrite.Write(tc.input)
				return err
			})
			// test the function
			mitmSrv := NewServer(false, true)
			assert.NoError(tt, mitmSrv.handleConn(ctx, log, upstreamRead, clientWrite,
				inboundPrefix, false, NewInboundPacketHandler()), name)
			if err := eg.Wait(); err != nil {
				tt.Fatal(err)
			}
			// validate client output
			if tc.expectForward {
				assert.Equal(tt, tc.input[tc.expectForwardOffset:], buf.Bytes())
			} else {
				assert.Equal(tt, []byte{}, buf.Bytes())
			}
			// slice up the input into packets and ensure test values are used
			var deviceSerial []byte
			testBuf := bufio.NewReader(bytes.NewBuffer(tc.input))
			packet, err := readPacket(testBuf, inboundPrefix)
			for ; len(packet) > 0; packet, err = readPacket(testBuf, inboundPrefix) {
				assert.NoError(tt, err, name)
				if err = validateCRC(packet, inboundCRCByteOrder); err == nil {
					deviceSerial, err = deviceSerialInbound(packet)
					assert.NoError(tt, err, name)
					assert.Equal(tt, []byte(testDeviceSerial), deviceSerial, name)
					tt.Log("assert test serial")
				}
				tt.Log("done test loop")
			}
			// last call to readPacket returns an error due to being unable to peek
			assert.Error(tt, err, name)
		})
	}
}
