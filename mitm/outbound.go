package mitm

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"log/slog"
	"slices"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

const (
	// packet structure constants
	outboundEnvelopeTSLen = 0x28
	outboundEnvelopeLen   = 0x20
	// cleartext body constants
	timeSyncLen = 0x60
	metricsLen  = 0x70
)

var (
	// known Device IDs
	deviceIDToModel = map[[8]byte]string{
		{0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55}: "HK1000",
	}
	// yes, this differs between inbound and outbound
	outboundCRCByteOrder = binary.BigEndian
	// outbound packet types
	packetTypeTimeSync        = []byte{0x03, 0x03}
	packetTypeMetrics0        = []byte{0x03, 0x04}
	packetTypeMetrics1        = []byte{0x03, 0x45}
	packetTypeTimeSyncRespAck = []byte{0x03, 0x10}
	// protocol constants
	// metricsAck is sent by the server when it receives data sucessfully
	metricsAck = []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	// timeSyncRespAck occasionally sent by local device after a timeSyncResp (?)
	timeSyncRespAck = []byte{
		0x12, 0x16, 0x12, 0x18, 0x00, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	// prometheus metrics
	labelNames = []string{"model", "serial"}
	// headline metrics
	powerGenerationWatts = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "power_generation_watts",
		Help: "Power generated by PV array. " +
			"Small negative values are a measurement error. This value is [0,Inf.).",
	}, labelNames)
	powerExportWatts = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "power_export_watts",
		Help: "Power exported to the grid. " +
			"Negative values indicate power is being imported.",
	}, labelNames)
	// other useful metrics
	energyGenerationDecawattHoursTotal = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "energy_generation_decawatt_hours_total",
		Help: "Cumulative energy generated.",
	}, labelNames)
	energyExportDecawattHoursTotal = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "energy_export_decawatt_hours_total",
		Help: "Cumulative energy exported. " +
			"When energy is imported, this value is static.",
	}, labelNames)
	energyImportDecawattHoursTotal = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "energy_import_decawatt_hours_total",
		Help: "Cumulative energy imported. " +
			"When energy is exported, this value is static.",
	}, labelNames)
	sumOfEnergyGenerationAndImportDecawattHoursTotal = promauto.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "sum_of_energy_generation_and_import_decawatt_hours_total",
			Help: "Sum of energy generation and import.",
		}, labelNames)
	// less useful and unknown metrics
	sumOfPowerGenerationAndExportWatts = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "sum_of_power_generation_and_export_watts",
		Help: "Sum of power generation and export. " +
			"Not particularly useful since it can double-count generated power.",
	}, labelNames)
	sumOfEnergyGenerationAndExportDecawattHoursTotal = promauto.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "sum_of_energy_generation_and_export_decawatt_hours_total",
			Help: "Sum of energy generation and export. " +
				"Not particularly useful since it can double-count generated energy.",
		}, labelNames)
	unknownInt5 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_5",
	}, labelNames)
	unknownInt6 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_6",
	}, labelNames)
	unknownInt7 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_7",
	}, labelNames)
	unknownInt8 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_8",
	}, labelNames)
	unknownInt9 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_9",
	}, labelNames)
	unknownInt10 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_10",
	}, labelNames)
	unknownInt11 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_11",
	}, labelNames)
	unknownInt12 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_12",
	}, labelNames)
	// expoerter internal metrics
	timeSyncPacketsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "time_sync_packets_total",
		Help: "Count of outbound time sync packets.",
	}, labelNames)
	timeSyncAckPacketsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "time_sync_ack_packets_total",
		Help: "Count of outbound time sync acknowledgement packets.",
	}, labelNames)
	metricsPacketsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "metrics_packets_total",
		Help: "Count of outbound metrics packets.",
	}, labelNames)
	unknownPacketsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "outbound_unknown_packets_total",
		Help: "Count of outbound unknown packets.",
	}, labelNames)
)

// OutboundHeader represents the header of an outbound packet.
type OutboundHeader struct {
	PostGW     [6]byte // POSTGW prefix
	Length     uint32  // Off-by-one
	PacketType [2]byte // Packet type identifier
}

// OutboundEnvelope is the plaintext wrapper around the ciphertext.
type OutboundEnvelope struct {
	DeviceID     [8]byte // ASCII
	DeviceSerial [8]byte // ASCII
	IV           [16]byte
}

// OutboundEnvelopeTS is the plaintext wrapper, with a timestamp, around the
// ciphertext.
type OutboundEnvelopeTS struct {
	UnknownBytes [2]byte // Fixed null alignment padding?
	DeviceID     [8]byte // ASCII
	DeviceSerial [8]byte // ASCII
	IV           [16]byte
	Timestamp    Timestamp // Y M D H m s
}

// OutboundTimeSync is the cleartext body of an outbound time sync packet.
type OutboundTimeSync struct {
	PacketType    [7]byte  // 0x00-0x06 Packet type?
	OutboundAddr  [40]byte // 0x07-0x2e Outbound TCP addr. Null-terminated ASCII.
	UnknownBytes1 [6]byte  // 0x2f-0x34 Unknown
	UnknownBytes2 [16]byte // 0x35-0x44 Serial number? ASCII.
	UnknownInt0   int32    // 0x45-0x48 Unknown
	UnknownBytes3 [4]byte  // 0x49-0x4c Unknown
	UnknownBytes4 [19]byte // 0x4d-0x5f Version numbers? Null-terminated ASCII.
}

// OutboundMetrics is the cleartext body of an outbound metrics packet.
type OutboundMetrics struct {
	PacketType                                       [7]byte  // 0x00-0x06 Packet type?
	EnergyExportDecawattHoursTotal                   int32    // 0x07-0x0a Units of 10 watt-hours
	UnknownBytes1                                    [2]byte  // 0x0b-0x0c Fixed null?
	EnergyGenerationDecawattHoursTotal               int32    // 0x0d-0x10 Units of 10 watt-hours
	UnknownBytes2                                    [8]byte  // 0x11-0x18 Fixed null?
	SumOfEnergyGenerationAndExportDecawattHoursTotal int32    // 0x19-0x1c Units of 10 watt-hours
	UnknownBytes3                                    [2]byte  // 0x1d-0x1e Fixed null?
	EnergyImportDecawattHoursTotal                   int32    // 0x1f-0x22 Units of 10 watt-hours
	UnknownBytes4                                    [16]byte // 0x23-0x32 Fixed bytes?
	SumOfEnergyGenerationAndImportDecawattHoursTotal int16    // 0x33-0x34 Units of 10 watt-hours
	UnknownInt5                                      int32    // 0x35-0x38 Fixed int value?
	UnknownInt6                                      int16    // 0x39-0x3a Gauge?
	UnknownInt7                                      int16    // 0x3b-0x3c Gauge?
	UnknownInt8                                      int16    // 0x3d-0x3e Incrementing counter?
	UnknownInt9                                      int32    // 0x3f-0x42 Gauge?
	UnknownInt10                                     int32    // 0x43-0x46 Gauge?
	UnknownInt11                                     int32    // 0x47-0x4a Fixed int zero?
	PowerExportWatts                                 int32    // 0x4b-0x4e
	PowerGenerationWatts                             int32    // 0x4f-0x52
	UnknownInt12                                     int32    // 0x53-0x56 Fixed int zero?
	SumOfPowerGenerationAndExportWatts               int32    // 0x57-0x5a Sum of GridWatts and PVWatts (sometimes slightly inaccurate?)
	UnknownBytes5                                    [21]byte // 0x5b-0x6f Fixed bytes?
}

// parseTimeSync unmarshals the time sync body.
func parseTimeSync(cleartext []byte) (*OutboundTimeSync, error) {
	if len(cleartext) != timeSyncLen {
		return nil, fmt.Errorf("invalid cleartext length: %d", len(cleartext))
	}
	body := OutboundTimeSync{}
	buf := bytes.NewBuffer(cleartext)
	if err := binary.Read(buf, binary.BigEndian, &body); err != nil {
		return nil, fmt.Errorf("couldn't read cleartext: %v", err)
	}
	return &body, nil
}

// handleTimeSyncPacket handles time sync packet envelope and ciphertext.
func handleTimeSyncPacket(
	buf *bytes.Buffer,
	headerLen uint32,
	log *slog.Logger,
) error {
	envelope := OutboundEnvelopeTS{}
	if err := binary.Read(buf, binary.BigEndian, &envelope); err != nil {
		return fmt.Errorf("couldn't read envelope: %v", err)
	}
	model, ok := deviceIDToModel[envelope.DeviceID]
	if !ok {
		return fmt.Errorf("unknown device ID: %v", envelope.DeviceID)
	}
	// -2 for packet type field in header and +1 for off-by-one = -1
	ciphertext := buf.Next(int(headerLen - outboundEnvelopeTSLen - 1))
	cleartext, err := decryptCiphertext(envelope.IV[:], ciphertext)
	if err != nil {
		log.Debug("couldn't decrypt ciphertext", slog.Any("ciphertext", ciphertext))
		return fmt.Errorf("couldn't decrypt ciphertext: %v", err)
	}
	_, err = parseTimeSync(cleartext)
	if err != nil {
		log.Debug("couldn't parse time sync", slog.Any("cleartext", cleartext))
		return fmt.Errorf("couldn't parse time sync: %v", err)
	}
	log.Debug("outbound time sync", slog.Any("cleartext", cleartext))
	timeSyncPacketsTotal.With(prometheus.Labels{
		"model":  model,
		"serial": string(envelope.DeviceSerial[:]),
	}).Inc()
	return nil
}

// parseMetrics unmarshals the metrics body.
func parseMetrics(cleartext []byte) (*OutboundMetrics, error) {
	if len(cleartext) != metricsLen {
		return nil, fmt.Errorf("invalid cleartext length: %d", len(cleartext))
	}
	body := OutboundMetrics{}
	buf := bytes.NewBuffer(cleartext)
	if err := binary.Read(buf, binary.BigEndian, &body); err != nil {
		return nil, fmt.Errorf("couldn't read cleartext: %v", err)
	}
	return &body, nil
}

// handleMetricsPacket handles metrics packet envelope and ciphertext.
func handleMetricsPacket(
	buf *bytes.Buffer,
	headerLen uint32,
	log *slog.Logger,
) error {
	envelope := OutboundEnvelopeTS{}
	if err := binary.Read(buf, binary.BigEndian, &envelope); err != nil {
		return fmt.Errorf("couldn't read envelope: %v", err)
	}
	model, ok := deviceIDToModel[envelope.DeviceID]
	if !ok {
		return fmt.Errorf("unknown device ID: %v", envelope.DeviceID)
	}
	// -2 for packet type field in header and +1 for off-by-one = -1
	ciphertext := buf.Next(int(headerLen - outboundEnvelopeTSLen - 1))
	cleartext, err := decryptCiphertext(envelope.IV[:], ciphertext)
	if err != nil {
		log.Debug("couldn't decrypt ciphertext", slog.Any("ciphertext", ciphertext))
		return fmt.Errorf("couldn't decrypt ciphertext: %v", err)
	}
	metrics, err := parseMetrics(cleartext)
	if err != nil {
		log.Debug("couldn't parse metrics", slog.Any("cleartext", cleartext))
		return fmt.Errorf("couldn't parse metrics: %v", err)
	}
	log.Debug("outbound metrics")
	labels := prometheus.Labels{
		"model":  model,
		"serial": string(envelope.DeviceSerial[:]),
	}
	// record metrics
	powerGenerationWatts.With(labels).Set(
		float64(metrics.PowerGenerationWatts))
	powerExportWatts.With(labels).Set(
		float64(metrics.PowerExportWatts))
	energyGenerationDecawattHoursTotal.With(labels).Set(
		float64(metrics.EnergyGenerationDecawattHoursTotal))
	energyExportDecawattHoursTotal.With(labels).Set(
		float64(metrics.EnergyExportDecawattHoursTotal))
	energyImportDecawattHoursTotal.With(labels).Set(
		float64(metrics.EnergyImportDecawattHoursTotal))
	sumOfEnergyGenerationAndImportDecawattHoursTotal.With(labels).Set(
		float64(metrics.SumOfEnergyGenerationAndImportDecawattHoursTotal))
	sumOfPowerGenerationAndExportWatts.With(labels).Set(
		float64(metrics.SumOfPowerGenerationAndExportWatts))
	sumOfEnergyGenerationAndExportDecawattHoursTotal.With(labels).Set(
		float64(metrics.SumOfEnergyGenerationAndExportDecawattHoursTotal))
	unknownInt5.With(labels).Set(float64(metrics.UnknownInt5))
	unknownInt6.With(labels).Set(float64(metrics.UnknownInt6))
	unknownInt7.With(labels).Set(float64(metrics.UnknownInt7))
	unknownInt8.With(labels).Set(float64(metrics.UnknownInt8))
	unknownInt9.With(labels).Set(float64(metrics.UnknownInt9))
	unknownInt10.With(labels).Set(float64(metrics.UnknownInt10))
	unknownInt11.With(labels).Set(float64(metrics.UnknownInt11))
	unknownInt12.With(labels).Set(float64(metrics.UnknownInt12))
	// record debug metrics
	metricsPacketsTotal.With(labels).Inc()
	return nil
}

// handleTimeSyncRespAckPacket handles time sync response ack packet envelope
// and ciphertext.
func handleTimeSyncRespAckPacket(
	buf *bytes.Buffer,
	headerLen uint32,
	log *slog.Logger,
) error {
	envelope := OutboundEnvelope{}
	if err := binary.Read(buf, binary.BigEndian, &envelope); err != nil {
		return fmt.Errorf("couldn't read envelope: %v", err)
	}
	model, ok := deviceIDToModel[envelope.DeviceID]
	if !ok {
		return fmt.Errorf("unknown device ID: %v", envelope.DeviceID)
	}
	// -2 for packet type field in header and +1 for off-by-one = -1
	ciphertext := buf.Next(int(headerLen - outboundEnvelopeLen - 1))
	cleartext, err := decryptCiphertext(envelope.IV[:], ciphertext)
	if err != nil {
		log.Debug("couldn't decrypt ciphertext", slog.Any("ciphertext", ciphertext))
		return fmt.Errorf("couldn't decrypt ciphertext: %v", err)
	}
	if !slices.Equal(timeSyncRespAck, cleartext) {
		log.Debug("unknown cleartext in timeSyncRespAck",
			slog.Any("cleartext", cleartext))
	}
	timeSyncAckPacketsTotal.With(prometheus.Labels{
		"model":  model,
		"serial": string(envelope.DeviceSerial[:]),
	}).Inc()
	return nil
}

// handleUnknownOutboundPacket assumes the packet is a metrics packet with a
// weird packet type, so tries to decrypt and parse it as such. This is mostly
// useful when occasionally the device sends a metrics packet with an unknown
// packet type header.
func handleUnknownOutboundPacket(
	buf *bytes.Buffer,
	headerLen uint32,
	log *slog.Logger,
) error {
	envelope := OutboundEnvelopeTS{}
	if err := binary.Read(buf, binary.BigEndian, &envelope); err != nil {
		return fmt.Errorf("couldn't read envelope: %v", err)
	}
	model, ok := deviceIDToModel[envelope.DeviceID]
	if !ok {
		return fmt.Errorf("unknown device ID: %v", envelope.DeviceID)
	}
	// -2 for packet type field in header and +1 for off-by-one = -1
	ciphertext := buf.Next(int(headerLen - outboundEnvelopeTSLen - 1))
	cleartext, err := decryptCiphertext(envelope.IV[:], ciphertext)
	if err != nil {
		log.Debug("couldn't decrypt ciphertext", slog.Any("ciphertext", ciphertext))
		return fmt.Errorf("couldn't decrypt ciphertext: %v", err)
	}
	log.Debug("decrypted unknown packet", slog.Any("cleartext", cleartext))
	metrics, err := parseMetrics(cleartext)
	if err != nil {
		log.Debug("couldn't parse metrics", slog.Any("cleartext", cleartext))
		return fmt.Errorf("couldn't parse metrics: %v", err)
	}
	// log values
	log.Debug("unknown metrics", slog.Any("metrics", metrics),
		slog.Time("timestamp", envelope.Timestamp.Time()))
	unknownPacketsTotal.With(prometheus.Labels{
		"model":  model,
		"serial": string(envelope.DeviceSerial[:]),
	}).Inc()
	return nil
}

// handleOutboundPacket is a handlePacketFunc for outbound packets.
func handleOutboundPacket(
	ctx context.Context,
	log *slog.Logger,
	data []byte,
) error {
	if err := validateCRC(data, outboundCRCByteOrder); err != nil {
		return fmt.Errorf("couldn't validate CRC: %v", err)
	}
	header := OutboundHeader{}
	buf := bytes.NewBuffer(data)
	if err := binary.Read(buf, binary.BigEndian, &header); err != nil {
		return fmt.Errorf("couldn't read header: %v", err)
	}
	switch {
	case slices.Equal(packetTypeTimeSync, header.PacketType[:]):
		if err := handleTimeSyncPacket(buf, header.Length, log); err != nil {
			return fmt.Errorf("couldn't handle time sync packet: %v", err)
		}
		return nil
	case slices.Equal(packetTypeMetrics0, header.PacketType[:]):
		fallthrough
	case slices.Equal(packetTypeMetrics1, header.PacketType[:]):
		if err := handleMetricsPacket(buf, header.Length, log); err != nil {
			return fmt.Errorf("couldn't handle metrics packet: %v", err)
		}
		return nil
	case slices.Equal(packetTypeTimeSyncRespAck, header.PacketType[:]):
		if err := handleTimeSyncRespAckPacket(buf, header.Length, log); err != nil {
			return fmt.Errorf("couldn't handle time sync response ack packet: %v", err)
		}
		return nil
	default:
		if err := handleUnknownOutboundPacket(buf, header.Length, log); err != nil {
			return fmt.Errorf("couldn't handle unknown packet: %v", err)
		}
		return fmt.Errorf("unknown packet type")
	}
}
