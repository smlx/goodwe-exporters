package mitm

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"log/slog"
	"slices"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

var (
	// known Device IDs
	deviceIDToModel = map[[8]byte]string{
		{0x39, 0x31, 0x30, 0x30, 0x30, 0x48, 0x4b, 0x55}: "HK1000",
	}
	// yes, this differs between inbound and outbound
	outboundCRCByteOrder = binary.BigEndian
	// outbound packet types
	packetTypeTimeSync        = []byte{0x03, 0x03}
	packetTypeMetrics0        = []byte{0x03, 0x04}
	packetTypeMetrics1        = []byte{0x03, 0x45}
	packetTypeTimeSyncRespAck = []byte{0x03, 0x10}
	// protocol constants
	// timeSyncRespAckData occasionally sent by device after a timeSyncResp (?)
	timeSyncRespAckData = []byte{
		0x12, 0x16, 0x12, 0x18, 0x00, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	// prometheus metrics
	labelNames = []string{"model", "serial"}
	// headline metrics
	powerGenerationWatts = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "power_generation_watts",
		Help: "Power generated by PV array. " +
			"Small negative values are a measurement error. This value is [0,Inf.).",
	}, labelNames)
	powerExportWatts = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "power_export_watts",
		Help: "Power exported to the grid. " +
			"Negative values indicate power is being imported.",
	}, labelNames)
	// other useful metrics
	energyGenerationDecawattHoursTotal = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "energy_generation_decawatt_hours_total",
		Help: "Cumulative energy generated.",
	}, labelNames)
	energyExportDecawattHoursTotal = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "energy_export_decawatt_hours_total",
		Help: "Cumulative energy exported. " +
			"When energy is imported, this value is static.",
	}, labelNames)
	energyImportDecawattHoursTotal = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "energy_import_decawatt_hours_total",
		Help: "Cumulative energy imported. " +
			"When energy is exported, this value is static.",
	}, labelNames)
	// less useful and unknown metrics
	sumOfEnergyImportLessGenerationDecawattHoursTotal = promauto.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "sum_of_energy_import_less_generation_decawatt_hours_total",
			Help: "Sum of energy import less generation. " +
				"Not particularly useful since it only increases while energy import is greater than generation.",
		}, labelNames)
	sumOfPowerGenerationAndExportWatts = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "sum_of_power_generation_and_export_watts",
		Help: "Sum of power generation and export. " +
			"Not particularly useful since it can double-count generated power.",
	}, labelNames)
	sumOfEnergyGenerationAndExportDecawattHoursTotal = promauto.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "sum_of_energy_generation_and_export_decawatt_hours_total",
			Help: "Sum of energy generation and export. " +
				"Not particularly useful since it can double-count generated energy.",
		}, labelNames)
	unknownInt5 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_5",
	}, labelNames)
	unknownInt6 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_6",
	}, labelNames)
	unknownInt7 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_7",
	}, labelNames)
	unknownInt8 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_8",
	}, labelNames)
	unknownInt9 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_9",
	}, labelNames)
	unknownInt10 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_10",
	}, labelNames)
	unknownInt11 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_11",
	}, labelNames)
	unknownInt12 = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "unknown_int_12",
	}, labelNames)
	// expoerter internal metrics
	timeSyncPacketsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "time_sync_packets_total",
		Help: "Count of outbound time sync packets.",
	}, labelNames)
	timeSyncAckPacketsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "time_sync_ack_packets_total",
		Help: "Count of outbound time sync acknowledgement packets.",
	}, labelNames)
	metricsPacketsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "metrics_packets_total",
		Help: "Count of outbound metrics packets.",
	}, labelNames)
	outboundUnknownPacketsTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "outbound_unknown_packets_total",
		Help: "Count of outbound unknown packets.",
	})
)

// handleTimeSyncPacket handles time sync packet envelope and ciphertext.
func handleTimeSyncPacket(
	data []byte,
	log *slog.Logger,
) error {
	var timeSync OutboundTimeSyncPacket
	err := timeSync.UnmarshalBinary(data)
	if err != nil {
		return fmt.Errorf("couldn't unmarshal time sync: %v", err)
	}
	model, ok := deviceIDToModel[timeSync.DeviceID]
	if !ok {
		return fmt.Errorf("unknown device ID: %v", timeSync.DeviceID)
	}
	log.Debug("outbound time sync")
	timeSyncPacketsTotal.With(prometheus.Labels{
		"model":  model,
		"serial": string(timeSync.DeviceSerial[:]),
	}).Inc()
	return nil
}

// handleMetricsPacket handles metrics packet envelope and ciphertext.
func handleMetricsPacket(
	data []byte,
	log *slog.Logger,
) (*OutboundMetricsPacket, error) {
	var metrics OutboundMetricsPacket
	err := metrics.UnmarshalBinary(data)
	if err != nil {
		return nil, fmt.Errorf("couldn't unmarshal metrics: %v", err)
	}
	model, ok := deviceIDToModel[metrics.DeviceID]
	if !ok {
		return nil, fmt.Errorf("unknown device ID: %v", metrics.DeviceID)
	}
	log.Debug("outbound metrics")
	labels := prometheus.Labels{
		"model":  model,
		"serial": string(metrics.DeviceSerial[:]),
	}
	// record metrics
	powerGenerationWatts.With(labels).Set(
		float64(metrics.PowerGenerationWatts))
	powerExportWatts.With(labels).Set(
		float64(metrics.PowerExportWatts))
	energyGenerationDecawattHoursTotal.With(labels).Set(
		float64(metrics.EnergyGenerationDecawattHoursTotal))
	energyExportDecawattHoursTotal.With(labels).Set(
		float64(metrics.EnergyExportDecawattHoursTotal))
	energyImportDecawattHoursTotal.With(labels).Set(
		float64(metrics.EnergyImportDecawattHoursTotal))
	sumOfEnergyImportLessGenerationDecawattHoursTotal.With(labels).Set(
		float64(metrics.SumOfEnergyImportLessGenerationDecawattHoursTotal))
	sumOfPowerGenerationAndExportWatts.With(labels).Set(
		float64(metrics.SumOfPowerGenerationAndExportWatts))
	sumOfEnergyGenerationAndExportDecawattHoursTotal.With(labels).Set(
		float64(metrics.SumOfEnergyGenerationAndExportDecawattHoursTotal))
	unknownInt5.With(labels).Set(float64(metrics.UnknownInt5))
	unknownInt6.With(labels).Set(float64(metrics.UnknownInt6))
	unknownInt7.With(labels).Set(float64(metrics.UnknownInt7))
	unknownInt8.With(labels).Set(float64(metrics.UnknownInt8))
	unknownInt9.With(labels).Set(float64(metrics.UnknownInt9))
	unknownInt10.With(labels).Set(float64(metrics.UnknownInt10))
	unknownInt11.With(labels).Set(float64(metrics.UnknownInt11))
	unknownInt12.With(labels).Set(float64(metrics.UnknownInt12))
	// record debug metrics
	metricsPacketsTotal.With(labels).Inc()
	return &metrics, nil
}

// handleTimeSyncRespAckPacket handles time sync response ack packet envelope
// and ciphertext.
func handleTimeSyncRespAckPacket(
	data []byte,
	log *slog.Logger,
) error {
	var timeSyncRespAck OutboundTimeSyncRespAckPacket
	err := timeSyncRespAck.UnmarshalBinary(data)
	if err != nil {
		return fmt.Errorf("couldn't unmarshal time sync: %v", err)
	}
	model, ok := deviceIDToModel[timeSyncRespAck.DeviceID]
	if !ok {
		return fmt.Errorf("unknown device ID: %v", timeSyncRespAck.DeviceID)
	}
	if !slices.Equal(timeSyncRespAckData, timeSyncRespAck.Data[:]) {
		log.Debug("unknown cleartext in timeSyncRespAck",
			slog.Any("cleartext", timeSyncRespAck.Data[:]))
	}
	log.Debug("outbound time sync response ack")
	timeSyncAckPacketsTotal.With(prometheus.Labels{
		"model":  model,
		"serial": string(timeSyncRespAck.DeviceSerial[:]),
	}).Inc()
	return nil
}

// handleUnknownOutboundPacket assumes the packet is a metrics packet with a
// weird packet type, so tries to decrypt and parse it as such. This is mostly
// useful when occasionally the device sends a metrics packet with an unknown
// packet type header.
func handleUnknownOutboundPacket(
	data []byte,
	log *slog.Logger,
) error {
	log.Info("unknown packet", slog.Any("data", data))
	outboundUnknownPacketsTotal.Inc()
	envelope := OutboundEnvelope{}
	envData, bodyData := data[:binary.Size(envelope)], data[binary.Size(envelope):]
	envBuf := bytes.NewBuffer(envData)
	err := binary.Read(envBuf, binary.BigEndian, &envelope)
	if err != nil {
		return fmt.Errorf("couldn't unmarshal envelope %T: %v", envelope, err)
	}
	cleartext, err := decryptCiphertext(envelope.IV[:], bodyData)
	if err != nil {
		return fmt.Errorf("couldn't decrypt ciphertext: %v", err)
	}
	log.Info("unknown packet cleartext", slog.Any("cleartext", cleartext))
	return nil
}

// OutboundPacketHandler is a PacketHandler for outbound packets.
type OutboundPacketHandler struct {
	batsignal bool
}

// NewOutboundPacketHandler constructs an OutboundPacketHandler.
func NewOutboundPacketHandler(batsignal bool) *OutboundPacketHandler {
	return &OutboundPacketHandler{
		batsignal: batsignal,
	}
}

// HandlePacket implements the PacketHandler interface.
func (h *OutboundPacketHandler) HandlePacket(
	ctx context.Context,
	log *slog.Logger,
	data []byte,
) ([]byte, error) {
	if err := validateCRC(data, outboundCRCByteOrder); err != nil {
		return nil, fmt.Errorf("couldn't validate CRC: %v", err)
	}
	// slice up the header and body, and discard CRC bytes
	header := OutboundHeader{}
	headerData, bodyData :=
		data[:binary.Size(header)], data[binary.Size(header):len(data)-2]
	if err := header.UnmarshalBinary(headerData); err != nil {
		return nil, fmt.Errorf("couldn't unmarshal header: %v", err)
	}
	// validate data size: -2 for packet type field and +1 for length off-by-one = -1
	expectedBodySize := header.Length - 1
	if len(bodyData) != int(expectedBodySize) {
		return nil, fmt.Errorf("expected body size %d, got %d",
			expectedBodySize, len(bodyData))
	}
	switch {
	case slices.Equal(packetTypeTimeSync, header.PacketType[:]):
		if err := handleTimeSyncPacket(bodyData, log); err != nil {
			return nil, fmt.Errorf("couldn't handle time sync packet: %v", err)
		}
		return nil, nil
	case slices.Equal(packetTypeMetrics0, header.PacketType[:]):
		fallthrough
	case slices.Equal(packetTypeMetrics1, header.PacketType[:]):
		metrics, err := handleMetricsPacket(bodyData, log)
		if err != nil {
			return nil, fmt.Errorf("couldn't handle metrics packet: %v", err)
		}
		if h.batsignal {
			newBodyData, err := batsignal(metrics)
			if err != nil {
				return nil, fmt.Errorf("couldn't signal batman: %v", err)
			}
			return append(headerData, newBodyData...), nil
		}
		return nil, nil
	case slices.Equal(packetTypeTimeSyncRespAck, header.PacketType[:]):
		if err := handleTimeSyncRespAckPacket(bodyData, log); err != nil {
			return nil, fmt.Errorf("couldn't handle time sync response ack packet: %v", err)
		}
		return nil, nil
	default:
		if err := handleUnknownOutboundPacket(bodyData, log); err != nil {
			return nil, fmt.Errorf("couldn't handle unknown packet: %v", err)
		}
		return nil, fmt.Errorf("unknown packet type")
	}
}
